<!--
  Copyright 2018, Bart Butenaers
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<script>
    // *****************************************************************************************
    // Load all external files (.js and .xml) ONCE for every page refresh
    // *****************************************************************************************
    
    // Make sure that all Blockly library files are loaded in the correct order.
    // Don't use jQuery (see https://discourse.nodered.org/t/scope-of-variables-in-external-js-scripts/1048/2)
    [
        "blocky/js/npm/blockly_compressed.js",
        //TODO "blocky/js/npm/msg/messages.js", // See https://groups.google.com/forum/#!topic/blockly/TwJTZct59ec
        "blocky/js/npm/blocks_compressed.js",
        "blocky/js/npm/javascript_compressed.js",
        "blocky/js/npm/msg/en.js",
        "blocky/js/messages/en.js", // Messages of custom blocks
        "blocky/js/npm2/field_date.js",
        "blocky/js/lib/json/objectBlocksCodeGen.js",
        "blocky/js/lib/json/objectBlocksDefs.js",
        "blocky/js/lib/nodered/nodeRedBlocksCodeGen.js",
        "blocky/js/lib/nodered/nodeRedBlocksDefs.js",
        "blocky/js/lib/extra/extraBlocksCodeGen.js",
        "blocky/js/lib/extra/extraBlocksDefs.js",
        "blocky/js/lib/buffer/bufferBlocksCodeGen.js",
        "blocky/js/lib/buffer/bufferBlocksDefs.js",
        "blocky/js/lib/datetime/dateTimeBlocksCodeGen.js",
        "blocky/js/lib/datetime/dateTimeBlocksDefs.js"
    ].forEach(function(src) {
        var script = document.createElement('script');
        script.type="text/javascript";
        script.async = false; // Force synchronous loading, to load them in the correct sequence
        script.src = src; 
        document.head.appendChild(script);
    });
    
    if (document.implementation.createDocument) {
        // Create a new XML document (which represents a toolbox), and keep it as a global variable.
        // All toolbox.xml files will be loaded and combined into the XML document.  
        // As soon as the XML document is complete, the toolbox will be displayed.
        // In e.g. Chrome you can skip the third parameter, but e.g. in Firefox you need at least pass a null.
        var toolboxXmlDocument = document.implementation.createDocument("https://developers.google.com/blockly/xml", "xml", null);
    }
    else {
        console.error('This browser cannot create a Blockly toolbox XML document (via createDocument)');
    }
    
    if (toolboxXmlDocument) {
        // Load the xml toolbox files for all available blocks libraries, and combine those into a single toolbox.
        // Remark: the categories are added in the same order as they are loaded here ...
        [
            "blocky/js/lib/nodered/toolbox.xml",
            "blocky/js/lib/json/toolbox.xml",
            "blocky/js/lib/buffer/toolbox.xml",
            "blocky/js/lib/datetime/toolbox.xml",        
            "blocky/js/lib/extra/toolbox.xml",
            "blocky/js/lib/basic/toolbox.xml"
        ].forEach(function(filePath) {
            var request = new XMLHttpRequest();
            request.open('GET', filePath, false);  // `false` makes the request synchronous
            request.send();
        
            if (request.readyState == 4 && request.status == 200) {
                // Get all categories in the new XML document
                var newCategories = request.responseXML.getElementsByTagName("category");
		
                // Iterate backwards since categories can be moved away from this list (to the toolbox)
                // 2021-03-25 Jeff: changed to while-loop to accommadate nested categories
                while (newCategories.length > 0) {
                    var newCategory = newCategories[0];
                    

                    // Get the category name
                    var name = newCategory.getAttribute('name');

                    // Try to find an existing category with the same name.
                    // Indeed multiple toolboxes can put blocks in the same category...
                    var existingCategory = toolboxXmlDocument.getElementsByName(name);
                    
                    if (existingCategory.length === 0) {
                        // If the new category didn't exist yet in the toolbox, append the entire new category to the toolbox
                        toolboxXmlDocument.documentElement.appendChild(newCategory);
                    }
                    else {
                        var newBlocks = newCategory.children;

                        // Move all the blocks (and their children) from the newCategory to the existingCategory.
                        // Remark: appendChild will remove the block from newBlocks!
                        while(newBlocks.length > 0) {
                            existingCategory[0].appendChild(newBlocks[0]);
                        }
                        // Remove the category from newCategories so the next loop is clean
                        newCategory.remove();
                    }

                }
            }
            else {
                console.error("The toolbox XML files for Blocky cannot be loaded"); 
            }
        });
    }
    else {
        console.error("The Blockly toolbox XML document has not been created"); 
    }
</script>

<script type="text/javascript">
    function createWorkspace(node, workspaceXml) {
        // Default settings in case no config node has been specified
        var showTrashcan     = true;
        var allowComments    = true;
        var showZoomControl  = true;
        var horizontalLayout = false;
        var toolboxPosition  = "start";
        var renderer         = "geras";          

        // When a config node has been specified, then use the settings from that node
        if (node.selectedConfigNodeId && node.selectedConfigNodeId !== "_ADD_") {
            var configNode = RED.nodes.node(node.selectedConfigNodeId);
            
            if (configNode) {
                showTrashcan    = configNode.showTrashcan;
                allowComments   = configNode.allowComments;
                showZoomControl = configNode.showZoomControl;
                renderer        = configNode.renderer;
 
                // The toolboxPosition from the config screen determines two separate blockly settings!
                switch(configNode.toolboxPosition) {
                    case "left":
                        horizontalLayout = false;
                        toolboxPosition  = "start";                    
                        break;
                    case "right":
                        horizontalLayout = false;
                        toolboxPosition  = "end";   
                        break;
                    case "top":
                        horizontalLayout = true;
                        toolboxPosition  = "start";   
                        break;
                }
            }
        }

        // Create the workspace (with the specified settings)
        node.workspace = Blockly.inject('blocklyDiv', {
            grid: {
                spacing: 25,
                length: 3,
                colour: '#ccc',
                snap: true
            },     
            toolbox: toolboxXmlDocument.firstElementChild,
            zoom: {
                controls: showZoomControl, 
                wheel: true
            },
            renderer: renderer,
            trashcan: showTrashcan,
            comments: allowComments,
            disable: true,
            scrollbars: true,
            horizontalLayout: horizontalLayout,
            toolboxPosition : toolboxPosition 
        });
        
        // The 'msg' variable represents the parameter from the Node-Red 'input' event.
        // By adding it as a reserved wordt in Javascript, we can avoid that users create their own 'msg' variable.
        // Idem for the 'global', 'flow' and 'context' memory in Node-Red.
        Blockly.JavaScript.addReservedWords(['msg', 'flow', 'context', 'global']);
        
        // Restore the workspace content from the XML string
        var dom = Blockly.Xml.textToDom(workspaceXml);
        Blockly.Xml.domToWorkspace(dom, node.workspace); 
        
        // Make sure the workspace is sized correctly in the beginning
        resize(node);
        node.workspace.scrollCenter();
    }
    
    function cleanup(node) {
        // Make sure that the Node-Red handles all keydown events again (e.g. 'D' to delete a node), instead of Blockly. 
        Blockly.blocklyEditorVisible = false;
        
        // When blocks are still available in Blockly's clipboard, Blockly CANNOT paste them in another workspace (of another node).
        // This means we can empty the clipboard (by setting it to null).  However we will store first a copy of their clipboard 
        // (as xml string) into our own custom clipboard, which we CAN use to paste in another workspace.
        if (Blockly.clipboardXml_) {
            Blockly.customClipboard = '<xml xmlns="https://developers.google.com/blockly/xml">' + Blockly.Xml.domToPrettyText(Blockly.clipboardXml_) + '</xml>';
            Blockly.clipboardXml_ = null;
        }
                            
        // When a copy is done in this blockly node, an error will occur if that content is pasted later in another blockly node.
        // Copy-paste across workspaces is not supported by Blockly (https://github.com/google/blockly/issues/334)
        Blockly.clipboardXml_ = null;
        Blockly.clipboardSource_ = null;

        // Cleanup the ACE editor
        node.aceEditor.destroy();
        delete node.aceEditor;

        // Jeff: Cleanup the XML editor 04/18/2021
        node.aceXMLEditor.destroy();
        delete node.aceXMLEditor;


        // Cleanup the Blockly workspace
        node.workspace.dispose(); 
        delete node.workspace;
    }
    
    function cleanup(node) {
        // Make sure that the Node-Red handles all keydown events again (e.g. 'D' to delete a node), instead of Blockly. 
        Blockly.blocklyEditorVisible = false;
        
        // When blocks are still available in Blockly's clipboard, Blockly CANNOT paste them in another workspace (of another node).
        // This means we can empty the clipboard (by setting it to null).  However we will store first a copy of their clipboard 
        // (as xml string) into our own custom clipboard, which we CAN use to paste in another workspace.
        if (Blockly.clipboardXml_) {
            Blockly.customClipboard = '<xml xmlns="http://www.w3.org/1999/xhtml">' + Blockly.Xml.domToPrettyText(Blockly.clipboardXml_) + '</xml>';
            Blockly.clipboardXml_ = null;
        }
                            
        // When a copy is done in this blockly node, an error will occur if that content is pasted later in another blockly node.
        // Copy-paste across workspaces is not supported by Blockly (https://github.com/google/blockly/issues/334)
        Blockly.clipboardXml_ = null;
        Blockly.clipboardSource_ = null;

        // Cleanup the ACE editor
        node.aceEditor.destroy();
        delete node.aceEditor;
             
        // Cleanup the Blockly workspace
        node.workspace.dispose(); 
        delete node.workspace;
    }
    
    // See https://developers.google.com/blockly/guides/configure/web/resizable
    function resize(node) {        
        // Resize the Blockly workspace, as soon as available (i.e. not when called from oneditprepare).
        if (node.workspace) {
            var blocklyArea = document.getElementById('blocklyArea');
            var blocklyDiv = document.getElementById('blocklyDiv');

            // Compute the absolute coordinates and dimensions of blocklyArea.
            var element = blocklyArea;
            var x = 0;
            var y = 0;
            //do {
                x += element.offsetLeft;
                y += element.offsetTop;
            //    element = element.offsetParent;
            //} while (element);
            
            // Position blocklyDiv over blocklyArea.
            blocklyDiv.style.left = x + 'px';
            blocklyDiv.style.top = y + 'px';
            blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';
            blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';
            
            // Make sure the Blockly svg area is resized according the DIV element.
            // Blocky itself also calls svgResize underneath, but only when e.g. the toolbox changes size)
            Blockly.svgResize(node.workspace);
            
        }
    };
    
    function fillAceEditor(node) { 
        // Store the number of output ports in Blockly,  so the blocks can take that number into account (if required)
        //Blockly.nodeOutputs = $("#node-input-outputs").val();
    
        // Generate JavaScript code from the workspace content
        Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
        var javascript = Blockly.JavaScript.workspaceToCode(node.workspace);
        
        // Show the generated Javascript code in the Ace editor
        node.aceEditor.setValue(javascript);
        
        // After setValue all code will be selected otherwise
        node.aceEditor.clearSelection(); 
    }


    function fillAceXMLEditor(node) {
        // Jeff: fill aceXMLEditor 04/18/2021
        // Store the number of output ports in Blockly,  so the blocks can take that number into account (if required)
        //Blockly.nodeOutputs = $("#node-input-outputs").val();

        // Generate JavaScript code from the workspace content
        var dom = Blockly.Xml.workspaceToDom(node.workspace);
        var loadedxml = Blockly.Xml.domToPrettyText(dom);
        // Show the generated XML code in the Ace editor
        node.aceXMLEditor.setValue(loadedxml);

        // After setValue all code will be selected otherwise
        node.aceXMLEditor.clearSelection();
    }


    function reloadBlockly(node) {
        // Jeff: fill aceXMLEditor 04/18/2021
        var loadedXml = node.aceXMLEditor.getValue();
        //var dom = Blockly.Xml.textToDom(loadedXml);
        //node.workspace.clear();
        //Blockly.Xml.domToWorkspace(dom, node.workspace);
        node.workspace.dispose();
        createWorkspace(node, loadedXml);
    }


    RED.nodes.registerType('Blockly',{
        category: 'function',
        color: '#FFAAAA',       
        defaults: {
            func: {value:"\nreturn msg;"}, // The generated Javascript code
            workspaceXml: {value:"<xml xmlns=\"https:\/\/developers.google.com\/blockly\/xml\"><\/xml>"}, // Needed for Blockly version "5.20210325.1". Can't be empty
            outputs: {value:1}, // Standard field that will be used by Node-Red to draw N output ports in the flow editor,
            blocklyConfig: {type: "blockly-config", required: false}, // No default value (see https://discourse.nodered.org/t/default-config-node/46773/9?u=bartbutenaers)
            name: {value:""}
        },
        inputs:1,
        outputs:1,
        icon: "puzzle.png",
        label: function() {
            return this.name||"Blockly";
        },
        oneditprepare: function() {
            var node = this;

            // Blockly has an onKeyDown handler, that handles a number of key combinations (ctrl-'C' to copy the selected
            // blocks, 'D' to delete the selected blocks, ctrl-'Z' to undo the last action).  However afterwards the keydown event
            // is passed to Node-Red which cannot handle it, resulting in errors in the log.
            // See https://github.com/bartbutenaers/node-red-contrib-blockly/issues/2
            // Make sure that Blockly only handles the keydown events when the Blockly editor is visible, and otherwise Node-Red will handle them.
            if (Blockly.blocklyEditorVisible === undefined) {
                Blockly.originalKeyDownHandler = Blockly.onKeyDown_;
                Blockly.onKeyDown_ = function(e) {
                    if (Blockly.blocklyEditorVisible) {
                        // Let Blockly handle the keydown event
                        Blockly.originalKeyDownHandler(e);
                        
                        // 
                        if (e.altKey || e.ctrlKey || e.metaKey) {
                            // Don't use meta keys during drags
                            if (!Blockly.mainWorkspace.isDragging()) {
                                // When pressing CTRL-V (paste) ...
                                if (e.keyCode == 86) {
                                    if (!Blockly.clipboardXml_ && Blockly.customClipboard) {
                                        // When the originalClipboardXml_ is null and the customClipboard is not empty, this means
                                        // we need to paste blocks that have been copied (to the customClipboard) in another node.
                                        var xmlDom = Blockly.Xml.textToDom(Blockly.customClipboard);
                                        Blockly.Xml.domToWorkspace(xmlDom, Blockly.mainWorkspace);
                                    }
                                }
                            }
                        }
                        
                        // Stop the events from propagating up the DOM tree
                        e.stopPropagation();
                    }
                }
            }
            Blockly.blocklyEditorVisible = true;
       
            // Make sure the Blockly node_send and node_return_message blocks are already at the beginning aware about the number of outputs
            Blockly.nodeOutputs = this.outputs

            $( "#node-input-outputs" ).spinner({
                min:1,
                change: function(event, ui) {
                    var value = this.value;
                    if (!value.match(/^\d+$/)) { value = 1;  }
                    else if (value < this.min) { value = this.min; }
                    if (value !== this.value) { $(this).spinner("value", value); }
                    
                    // Make sure the Blockly node_send and node_return_message blocks are always aware about the number of outputs
                    Blockly.nodeOutputs = parseInt(value);
                    
                    var blocks = node.workspace.getAllBlocks();
                    for(var i = 0; i < blocks.length; i++) {
                        if (blocks[i].type === "node_send" || blocks[i].type === "node_return_message") {
                            if( parseInt(blocks[i].getFieldValue('OUTPUT_NR')) > parseInt(value)) {
                                alert("There are '" + blocks[i].type.replace(/_/g, ' ') + "' blocks available that use a higher output number");
                                break;
                            }
                        }
                    }
                }
            });
            
            // Store the loaded config node id (temporarliy) in the node, because the blockly-node's config screen will
            // be cleaned up before we navigate to the tray screen.  From then on the $("#node-input-blocklyConfig") won't be accessible anymore...
            // Don't use node.blocklyConfig for this purpose, because that need to be unchanged in case the "Cancel" button is clicked.
            node.selectedConfigNodeId = $("#node-input-blocklyConfig").val();

            // Jeff: Moved to here for initializing Blockly workspace before creating tabs. It will be reloaded when the tabs created.
            createWorkspace(node, node.workspaceXml);

            node.aceEditor = RED.editor.createEditor({
                id: 'aceDiv',
                mode: 'ace/mode/nrjavascript', // serverside NodeRed editor
                value: node.func,
                readOnly: true
            });
            node.aceEditor.setFontSize(14); 

            // Jeff: create XML editor
            node.aceXMLEditor = RED.editor.createEditor({
                id: 'aceXMLDiv',
                mode: 'ace/mode/xml',
                value: node.workspaceXml,
                readOnly: true
            });
            node.aceXMLEditor.setFontSize(12);
            // Jeff: invoke when either fillAceXMLEditor triggered or loaded XML from library
            node.aceXMLEditor.on("change", function () {
                var loadedXml = node.aceXMLEditor.getValue();
                // Jeff: it seems everytime anything loads to the editor it removes the previous contents and then inject the new contents.
                // so there are two changes. 
                if (loadedXml != "") {
                    node.workspace.dispose();
                    Blockly.nodeOutputs = parseInt($("#node-input-outputs")[0].value);
                    createWorkspace(node, loadedXml);
                }
            });

            // Show three tabsheets
            var tabs = RED.tabs.create({
                id: "node-blocky-tabs",
                onchange: function(tab) {
                    // Show only the content (i.e. the children) of the selected tabsheet, and hide the others
                    $("#node-blocky-tabs-content").children().hide();
                    $("#" + tab.id).show();

                    // Every time the ace editor is displayed, the Javascript code should be regenerated (from the Blockly workspace);
                    // and the xml editor should be refilled (from the Blockly workspace)
                    if (tab.id === "node-blocky-tab-javascript") {
                        fillAceXMLEditor(node);
                        fillAceEditor(node);
                    }
                    if (tab.id === "node-blocky-tab-xml") {
                        fillAceXMLEditor(node);
                    }
                    if (tab.id === "node-blocky-tab-workspace") {
                        reloadBlockly(node);
                    }
                }
            });
            tabs.addTab({
                id: "node-blocky-tab-workspace",
                label: "Editor"
            });
            tabs.addTab({
                id: "node-blocky-tab-javascript",
                label: "Generated Javascript"
            });
            tabs.addTab({
                id: "node-blocky-tab-xml",
                label: "Generated XML"
            });

            // Need to wait for it to be rendered before the sizing of the tabs can be properly calculated
            setTimeout(function() {
                tabs.resize();
            }, 0);

            RED.library.create({
                url:"blockly_functions", // where to get the data from
                type:"Blockly", // the type of object the library is for
                // Jeff: load XML to aceXMLEditor instead aceEditor
                editor:node.aceXMLEditor, // the field name the main text body goes to
                mode:"ace/mode/xml",
                fields:['name','outputs']
            });
            

            // Display a tip if the Node-Red version is below 0.19.0
            var versionParts = RED.settings.version.split('.');
            if (versionParts[0] == 0 && versionParts[1] < 19) {
                $("#tip-version").show();
            } else {
                $("#tip-version").hide();
            }
            
            //Jeff: called when the expand button clicked
            var expandTemplate = 
            '<!-- Blockly editor -->'+
            '<div id="blocklyArea" style="width: 100%; height: 100%; min-height:350px;">'+
                '<div id="blocklyDiv"></div>'+
            '</div>'+
            '<div id="jsArea" class="form-row node-text-editor-row" style="width: 100%; height: 100%; min-height:350px; display: none;">'+
                '<div id="aceDiv" style="width: 100%; height: 100%;"></div>'+
            '</div>';

            var expandBlocklyHandler = function() {
                return function(e) {
                    e.preventDefault();
                    RED.view.state(RED.state.EDITING);
                    var trayOptions = {
                        title: "Blockly Workspace",
                        width: "Infinity",
                        buttons: [
                            {
                                id: "node-showBlocklyArea",
                                text: "Back to Blockly Editor",
                                click: function() {
                                    $("#jsArea").css("display","none");
                                    $("#blocklyArea").css("display","block");
                                    $("#node-showJSArea").css("display","block");
                                    $("#node-showBlocklyArea").css("display","none");
                                    var dom = Blockly.Xml.workspaceToDom(node.workspace);
                                    var loadedXml = Blockly.Xml.domToPrettyText(dom);
                                    node.workspace.dispose();

                                    createWorkspace(node, loadedXml);
                                }
                            },
                            {
                                id: "node-showJSArea",
                                text: "See Generated Javascript",
                                click: function() {
                                    $("#blocklyArea").css("display","none");
                                    $("#jsArea").css("display","block");
                                    $("#node-showBlocklyArea").css("display","block");
                                    $("#node-showJSArea").css("display","none");
                                    Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
                                    var javascript = Blockly.JavaScript.workspaceToCode(node.workspace);
                                    node.jseditor.setValue(javascript);
                                    node.jseditor.clearSelection(); 
                                }
                            },
                            {
                                id: "node-dialog-cancel",
                                text: RED._("common.label.cancel"),
                                click: function() {
                                    var loadedXml = node.loadedXml;
                                    node.workspace.dispose();

                                    //Jeff: re-create workspace after RED.tray.close finished
                                    RED.tray.close(() => createWorkspace(node, loadedXml));
                                }
                            },
                            {
                                id: "node-dialog-ok",
                                text: RED._("common.label.done"),
                                class: "primary",
                                click: function() {
                                    var dom = Blockly.Xml.workspaceToDom(node.workspace);
                                    var loadedXml = Blockly.Xml.domToPrettyText(dom);
                                    node.workspace.dispose();

                                    RED.tray.close(() => createWorkspace(node, loadedXml));
                                }
                            }
                        ],
                        resize: function(dimensions) {
                            var height = $("#blocklyArea").height();
                            var width = $("#blocklyArea").width();
                            $("#blocklyDiv").css("height",height+"px");
                            $("#blocklyDiv").css("width",width+"px");
                            Blockly.svgResize(node.workspace);
                            node.workspace.scrollCenter();
                        },
                        open: function(tray) {
                            $("#node-showBlocklyArea").css({"float":"left","display":"none"});
                            $("#node-showJSArea").css("float","left");
                            var trayBody = tray.find('.red-ui-tray-body');
                            //var blocklyAreaContent = $('<div id="blocklyArea" style="width: 100%; height: 100%; min-height:700px;"></div>').appendTo(trayBody);
                            //var blocklyDivContent = $('<div id="blocklyDiv"></div>').appendTo(blocklyAreaContent);
                            $(expandTemplate).appendTo(trayBody);
                            //Jeff: load workspace to a temp XML
                            var dom = Blockly.Xml.workspaceToDom(node.workspace);
                            node.loadedXml = Blockly.Xml.domToPrettyText(dom);

                            node.workspace.dispose();
                            createWorkspace(node, node.loadedXml);
                            node.jseditor = RED.editor.createEditor({
                                id: 'aceDiv',
                                mode: 'ace/mode/nrjavascript', // serverside NodeRed editor
                                value: node.func,
                                readOnly: true
                            });
                            node.jseditor.setFontSize(14); 
                        },
                        close: function() {
                            delete node.loadedXml;   
                            node.jseditor.destroy();
                            delete node.jseditor;
                        },
                        show: function() {

                        }
                    }
                    RED.tray.show(trayOptions);
                }
            }

            //Jeff: expand Blockly editing area
            $("#blocklyExpandDiv").on("click", expandBlocklyHandler());
     
            // When a new config is selected, a new Blockly workspace should be drawn (with the new config settings)        
            $("#node-input-blocklyConfig").on('change', function() {
                // Store the newly selected config node id (temporarliy) in the node, because the blockly-node's config screen will
                // be cleaned up before we navigate to the tray screen.  From then on the $("#node-input-blocklyConfig") won't be accessible anymore...
                // Don't use node.blocklyConfig for this purpose, because that need to be unchanged in case the "Cancel" button is clicked.
                node.selectedConfigNodeId = $("#node-input-blocklyConfig").val();
                
                var counter = 0;
                var language = "en";

                if (node.selectedConfigNodeId && node.selectedConfigNodeId !== "_ADD_") {
                    var configNode = RED.nodes.node(node.selectedConfigNodeId);
                    if (configNode && configNode.language) {
                        language = configNode.language;
                    }
                }
                
                // Make sure the Blockly datetime_convert_from_date block is always aware about the number of outputs
                Blockly.blocklyEditorLanguage = language;
        
                // When another language is selected, then load the file with the translations in that language.
                // Those translated texts will override the english text (which has been loaded at the start in the en.js file).
                // First load the english texts and afterwards the translated texts: if some translations are missing, the original
                // english texts will be used.  Note that the blocky/js/npm/msg/en.js file contains a Blockly.Msg = {} 
                var scripts = [
                  "blocky/js/npm/msg/en.js",
                  "blocky/js/npm/msg/" + language + ".js",
                  "blocky/js/messages/en.js",
                  "blocky/js/messages/" + language + ".js"
                ]
                
                scripts.forEach(function(src) {
                    var script = document.createElement('script');
                    script.type = "text/javascript";
                    script.async = false; // Force synchronous loading, to load them in the correct sequence
                  
                    // Show the entire workspace in the new selected value, by rendering after the scripts are loaded
                    script.onload = function() {
                        counter++;
                        
                        // Only do this when the last script has been loaded, otherwise we get errors do to missing messages.
                        // See https://github.com/bartbutenaers/node-red-contrib-blockly/issues/63#issuecomment-855301449
                        if (counter === scripts.length) {
                            // Blocks may look completely different in another language, due to differences in word-order. 
                            // As a result the language of a running Blockly instance cannot be changed.  
                            // To avoid a page reload, build the workspace again (based on the original workspace xml).
                            // See https://github.com/google/blockly/issues/701
                            var dom = Blockly.Xml.workspaceToDom(node.workspace);
                            var workspaceXml = Blockly.Xml.domToPrettyText(dom);
                            
                            // Destroy the current workspace
                            node.workspace.dispose();
                            
                            createWorkspace(node, workspaceXml);
                        }
                    }
                  
                    script.src = src; 
                    document.head.appendChild(script);
                });
            });
            $("#node-input-blocklyConfig").change();
        },
        oneditsave: function() {
            var node = this;
                        
            // Store the number of output ports in Blockly,  so the blocks can take that number into account (if required)
            //Blockly.nodeOutputs = $("#node-input-outputs").val(); 
  
            // Generate JavaScript code from the workspace content, and store it in this node.
            // That way it can be send to the server, where it will be executed in the sandbox.
            Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
            node.func = Blockly.JavaScript.workspaceToCode(node.workspace);
            
            // Store the workspace content as an xml string (which will produce a minimal ugly string).
            // To obtain a more readable (but larger) string, use Blockly.Xml.domToPrettyText instead.
            var dom = Blockly.Xml.workspaceToDom(node.workspace);
            node.workspaceXml = Blockly.Xml.domToPrettyText(dom);

            cleanup(node);
        },
        oneditcancel: function() {
            var node = this;
            
            cleanup(node);
        },
        oneditresize: function (size) {
            var node = this;
            var height = $("#blocklyArea").height();
            var width = $("#blocklyArea").width();
            $("#blocklyDiv").css("height",height+"px");
            $("#blocklyDiv").css("width",width+"px");
            Blockly.svgResize(node.workspace);
            //node.workspace.scrollCenter();
        }
    });
</script>

<script type="text/html" data-template-name="Blockly">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name" style="width:70%;">
    </div>
    <div class="form-row">
        <label for="node-input-blocklyConfig"><i class="fa fa-cog"></i> Config</label>
        <!-- Node-Red will replace this input element by a drop-down (with available OnVif device configurations) -->
        <input type="text" id="node-input-blocklyConfig">
    </div>
    </br>
    <div class="form-row">
        <!-- Three tabsheets -->
        <ul style="background: #fff; min-width: 600px; margin-bottom: 20px;" id="node-blocky-tabs"></ul>
    </div>
    <div id="node-blocky-tabs-content" style="min-height: 350px">
        <div id="node-blocky-tab-workspace">
            <div class="form-row">
                <!-- Blockly editor -->
                <div id="blocklyArea" style="width: 100%; height: 450px; min-height:350px;">
                    <div id="blocklyDiv"></div>
                    <div style="position: absolute; left:188px; bottom: calc(100% - 172px); z-index: 99;">
                        <button id="blocklyExpandDiv" class="red-ui-button red-ui-button-small"><i class="fa fa-expand"></i></button>
                    </div>
                </div>
            </div>
        </div>
        <div id="node-blocky-tab-javascript">
            <div class="form-row node-text-editor-row">
                <!-- <div style="position: absolute; right:0; bottom:calc(100% + 3px);"><button id="node-function-expand-js" class="editor-button editor-button-small"><i class="fa fa-expand"></i></button></div>-->
                <!-- Ace editor for generated Javascript code -->
                <div id="aceDiv" style="width: 100%; height: 450px; min-height:350px;"></div>
            </div>
        </div>
        <div id="node-blocky-tab-xml">
            <div class="form-row node-text-editor-row">
                <!-- <div style="position: absolute; right:0; bottom:calc(100% + 3px);"><button id="node-function-expand-js" class="editor-button editor-button-small"><i class="fa fa-expand"></i></button></div>-->
                <!-- Ace XML editor for generated XML code -->
                <div id="aceXMLDiv" style="width: 100%; height: 450px; min-height:350px;">
                </div>
            </div>
        </div>
    </div>
    <div class="form-row">
        <label for="node-input-outputs"><i class="fa fa-random"></i> Outputs</label>
        <input id="node-input-outputs" style="width: 20px;" value="1">
    </div>
    <div class="form-tips" id="tip-version" style="width: 100%;max-width: 100%;" hidden>Tip: The 'get node property' block cannot be used, since Node-red version 0.19.0 is minimal required.</div>
    </br>
</script>

<script type="text/html" data-help-name="Blockly">
    <p>A visual programming interface, to make programming a function node easier. Just drag and drop <a target="_blank" href="https://developers.google.com/blockly/">Blockly</a> 
    blocks to build your program logic, without having to write the Javascript code yourself.  The generated javascript code will be run against the messages being received by the node.</p>
    <p>The messages are passed in as a JavaScript object called <code>msg</code>.</p>
    <p>By convention it will have a <code>msg.payload</code> property containing the body of the message.</p>
    <p>The function is expected to return a message object (or multiple message objects), but can choose to return nothing in order to halt a flow.</p>
    <p>See <a target="_blank" href="https://github.com/bartbutenaers/node-red-contrib-blockly">Github</a> for a basic introduction on writing functions with Blockly, or our 
    <a target="_blank" href="https://github.com/bartbutenaers/node-red-contrib-blockly/wiki">wiki</a> pages for tutorials.  And lot's of other Blockly documentation (tutorials, video's, ...) can be found all over the internet.</p>
    <h3>Details</h3>
    <p>The Blockly editor contains the basic blocks provided by Google.  In addition a number of extra blocks have been provided.  A number of those extra blocks allow to communicate with the Node-Red API, similar to a normal function node.</p>
    <h3>CAUTION</h3>
    <p>Blockly is 1-based while Javascript is 0-based, which means that Blockly starts counting from 0 in a loop.  The numbers are <strong>automatically decremented</strong> (-1) in the generated code.</p>
</script>
